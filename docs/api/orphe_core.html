<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>orphe_core API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orphe_core</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="orphe_core.to_timestamp"><code class="name flex">
<span>def <span class="ident">to_timestamp</span></span>(<span>hours, minutes, seconds, ms_high, ms_low)</span>
</code></dt>
<dd>
<div class="desc"><p>v3のデータについてくるタイムスタンプをフォーマットする関数</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hours</code></strong></dt>
<dd>時</dd>
<dt><strong><code>minutes</code></strong></dt>
<dd>分</dd>
<dt><strong><code>seconds</code></strong></dt>
<dd>秒</dd>
<dt><strong><code>ms_high</code></strong></dt>
<dd>ミリ秒の上位バイト</dd>
<dt><strong><code>ms_low</code></strong></dt>
<dd>ミリ秒の下位バイト</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orphe_core.AccData"><code class="flex name class">
<span>class <span class="ident">AccData</span></span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>x軸の加速度</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y軸の加速度</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z軸の加速度</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccData:
    &#34;&#34;&#34;
    加速度センサの値を格納するクラス

    Attributes:
        x: x軸の加速度
        y: y軸の加速度
        z: z軸の加速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Acc[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.x}, {self.y}, {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.AccData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.DeviceInformation"><code class="flex name class">
<span>class <span class="ident">DeviceInformation</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>デバイス情報を格納するクラス
data: 生データ
battery: バッテリー残量
lr: LR
rec: REC
auto_run: Auto Run
led(int): LED発光の強さ 0-255
log_high: Log High
log_low: Log Low
range: レンジ
device_information: 取得したデバイス情報の保管用メンバ変数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceInformation:
    &#34;&#34;&#34;
    デバイス情報を格納するクラス
    data: 生データ
    battery: バッテリー残量
    lr: LR
    rec: REC
    auto_run: Auto Run
    led(int): LED発光の強さ 0-255
    log_high: Log High
    log_low: Log Low
    range: レンジ
    device_information: 取得したデバイス情報の保管用メンバ変数
    &#34;&#34;&#34;

    def __init__(self, data):
        self.data = data
        self.battery = int.from_bytes(data[0:1], byteorder=&#39;big&#39;, signed=False)
        self.lr = int.from_bytes(data[1:2], byteorder=&#39;big&#39;, signed=False)
        self.rec = int.from_bytes(data[2:3], byteorder=&#39;big&#39;, signed=False)
        self.auto_run = int.from_bytes(
            data[3:4], byteorder=&#39;big&#39;, signed=False)
        self.led = int.from_bytes(data[4:5], byteorder=&#39;big&#39;, signed=False)
        self.log_high = int.from_bytes(
            data[6:7], byteorder=&#39;big&#39;, signed=False)
        self.log_low = int.from_bytes(data[7:8], byteorder=&#39;big&#39;, signed=False)
        self.range = Range()
        self.range.acc = int.from_bytes(
            data[8:9], byteorder=&#39;big&#39;, signed=False)
        self.range.gyro = int.from_bytes(
            data[9:10], byteorder=&#39;big&#39;, signed=False)
        self.device_information = None</code></pre>
</details>
</dd>
<dt id="orphe_core.GaitData"><code class="flex name class">
<span>class <span class="ident">GaitData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>歩行解析の値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>gait_type</code></strong></dt>
<dd>歩容タイプ（0:無し、1:歩行、2:走行,3:直立静止）</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>ストライド方向（0:なし, 1:前方, 2:後方,3:内側,4:外側）</dd>
<dt><strong><code>calorie</code></strong></dt>
<dd>総消費カロリー</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>総移動距離</dd>
<dt><strong><code>standing_phase_duration</code></strong></dt>
<dd>立脚期継続時間</dd>
<dt><strong><code>swing_phase_duration</code></strong></dt>
<dd>遊脚期継続時間</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GaitData:
    &#34;&#34;&#34;
    歩行解析の値を格納するクラス

    Attributes:
        step_count: 歩数
        gait_type: 歩容タイプ（0:無し、1:歩行、2:走行,3:直立静止）
        direction: ストライド方向（0:なし, 1:前方, 2:後方,3:内側,4:外側）
        calorie: 総消費カロリー
        distance: 総移動距離
        standing_phase_duration: 立脚期継続時間
        swing_phase_duration: 遊脚期継続時間
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4番目は最初の2ビット分が enumで歩容タイプ（0:無し、1:歩行、2:走行,3:直立静止）
        self.gait_type = data[4] &amp; 0b00000011
        # 4番目は2,3,4ビット分がenumでストライド方向（0:なし, 1:前方, 2:後方,3:内側,4:外側）
        self.direction = (data[4] &amp; 0b00011100) &gt;&gt; 2
        # data[6],data[7]はfloat16で総消費カロリー
        self.calorie = struct.unpack(&#39;&gt;e&#39;, data[6:8])
        # 8,9,10,11はfloat32で総移動距離
        self.distance = struct.unpack(&#39;&gt;f&#39;, data[8:12])
        # 12,13,14,15はfloat32で立脚期継続時間（standing phase duration）
        self.standing_phase_duration = struct.unpack(&#39;&gt;f&#39;, data[12:16])
        # 16,17,18,19はflaot32で遊脚期継続時間（swing_phase_duration)
        self.swing_phase_duration = struct.unpack(&#39;&gt;f&#39;, data[16:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Gait type: {self.gait_type}&#34;)
        print(f&#34;Direction: {self.direction}&#34;)
        print(f&#34;Calorie: {self.calorie}&#34;)
        print(f&#34;Distance: {self.distance}&#34;)
        print(f&#34;Standing phase duration: {self.standing_phase_duration}&#34;)
        print(f&#34;Swing phase duration: {self.swing_phase_duration}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.GaitData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.GyroData"><code class="flex name class">
<span>class <span class="ident">GyroData</span></span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>x軸の角速度</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y軸の角速度</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z軸の角速度</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GyroData:
    &#34;&#34;&#34;
    ジャイロセンサの値を格納するクラス

    Attributes:
        x: x軸の角速度
        y: y軸の角速度
        z: z軸の角速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Gyro[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.x}, {self.y}, {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.GyroData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.Orphe"><code class="flex name class">
<span>class <span class="ident">Orphe</span></span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのBLE通信を行うクラス</p>
<p>コンストラクタ</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orphe:

    &#34;&#34;&#34;
    ORPHE COREのBLE通信を行うクラス
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        コンストラクタ
        &#34;&#34;&#34;
        self.serial_number_prev = 0
        self.client = None
        self.step_count = StepCount()  # 歩数

    def set_lost_data_callback(self, callback):
        &#34;&#34;&#34;
        データが欠損したときに呼び出されるコールバック関数を設定する

        Args:
            callback: コールバック関数
        &#34;&#34;&#34;
        self.lost_data_callback = callback

    def set_got_acc_callback(self, callback):
        &#34;&#34;&#34;加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。

        例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。
        &#34;&#34;&#34;
        self.got_acc_callback = callback

    def set_got_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_gyro_callback = callback

    def set_got_converted_acc_callback(self, callback):
        &#34;&#34;&#34;
        加速度センサの値を取得したときに呼び出されるコールバック関数を設定する

        それぞれの値は加速度レンジの値によって変換されます。
        例えば静止状態ではz方向の1Gの値は常に1.0です。
        &#34;&#34;&#34;
        self.got_converted_acc_callback = callback

    def set_got_converted_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_converted_gyro_callback = callback

    def set_got_quat_callback(self, callback):
        &#34;&#34;&#34;
        クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_quat_callback = callback

    def set_got_gait_callback(self, callback):
        &#34;&#34;&#34;
        歩行解析の値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_gait_callback = callback

    def set_got_stride_callback(self, callback):
        &#34;&#34;&#34;
        ストライドの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_stride_callback = callback

    def set_got_pronation_callback(self, callback):
        &#34;&#34;&#34;
        プロネーションの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_pronation_callback = callback

    def set_got_quat_distance_callback(self, callback):
        &#34;&#34;&#34;
        クォータニオンと差分値を取得したときに呼び出されるコールバック関数を設定する                
        &#34;&#34;&#34;
        self.got_quat_distance_callback = callback

    def set_on_disconnect_callback(self, callback):
        &#34;&#34;&#34;
        ORPHE COREとの接続が切断されたときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.on_disconnect_callback = callback

    async def scan_all_devices(self):
        &#34;&#34;&#34;
        すべてのBLEデバイスをスキャンして、その結果を返す

        Returns:
            BLEデバイスのリスト
        &#34;&#34;&#34;
        print(&#34;Scanning all BLE devices...&#34;)
        devices = await BleakScanner.discover()
        return devices

    async def connect(self, address=None):
        &#34;&#34;&#34;
        ORPHE COREと接続する

        Args:
            address: 接続するデバイスのアドレス。指定しない場合はスキャンしてSERVICE UUIDで合致するものに接続する
        Returns: 
            接続に成功した場合はTrue、失敗した場合はFalse
        &#34;&#34;&#34;
        print(
            f&#34;Scanning for ORPHE CORE BLE device...[address specified: {address}]&#34;)
        devices = await BleakScanner.discover()

        target_device = None

        if address is not None:
            for device in devices:
                if device.address == address:
                    target_device = device
                    print(
                        f&#34;Found target device: {device.name}(name), {device.address}(address)&#34;)
                    break
        else:
            for device in devices:
                #  device.name に CR-* が含まれている場合に接続する
                if device.name is not None and &#34;CR-&#34; in device.name:
                    target_device = device
                    print(
                        f&#34;Found target device: {device.name}(name), {device.address}(address)&#34;)
                    break

        if target_device is None:
            print(&#34;Target device not found.&#34;)
            return False

        self.client = BleakClient(target_device.address)
        await self.client.connect()
        if self.client.is_connected:
            print(&#34;Connected to the device&#34;)
            # 別のタスクで接続状態を監視
            asyncio.create_task(self.monitor_connection(self.client))

            return True
        else:
            print(&#34;Failed to connect to the device&#34;)
            return False

    async def monitor_connection(self, client):
        while True:
            await asyncio.sleep(1)  # 1秒ごとに接続状態をチェック
            if not client.is_connected:
                await self.disconnect_callback(self)
                break

    async def disconnect_callback(self, owner):
        # コールバック関数が設定されている場合、コールバック関数を呼び出す
        if hasattr(owner, &#39;on_disconnect_callback&#39;) and owner.on_disconnect_callback:
            owner.on_disconnect_callback()

    def is_connected(self):
        &#34;&#34;&#34;
        ORPHE COREに接続されているかどうかを返す

        Returns:
            接続されている場合はTrue、されていない場合はFalse
        &#34;&#34;&#34;
        if self.client is None:
            return False
        return self.client.is_connected

    async def read_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
        Returns: DeviceInformationクラスのインスタンス
        &#34;&#34;&#34;
        di = await self.client.read_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID)
        di = DeviceInformation(di)
        self.device_information = di  # デバイス情報をメンバ変数として保存（更新）しておく
        return di

    async def print_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途
        &#34;&#34;&#34;
        di = await self.read_device_information()
        print(f&#34;Battery: {di.battery}&#34;)
        print(f&#34;LR: {di.lr}&#34;)
        print(f&#34;REC: {di.rec}&#34;)
        print(f&#34;Auto Run: {di.auto_run}&#34;)
        print(f&#34;LED: {di.led}&#34;)
        print(f&#34;Log High: {di.log_high}&#34;)
        print(f&#34;Log Low: {di.log_low}&#34;)
        print(f&#34;ACC Range: {di.range.acc}&#34;)
        print(f&#34;GYRO Range: {di.range.gyro}&#34;)

    async def set_led(self, is_on, pattern):
        &#34;&#34;&#34;
        is_on(int): 0 or 1
        pattern(int): 0-4
        Returns: None
        &#34;&#34;&#34;
        # print(f&#34;Setting LED: {is_on}, {pattern}&#34;)
        # is_on, patternの値の範囲をチェック
        if is_on &lt; 0 or is_on &gt; 1:
            print(&#34;is_on must be 0 or 1.&#34;)
            return
        if pattern &lt; 0 or pattern &gt; 4:
            print(&#34;pattern must be 0-4.&#34;)
            return

        ba = bytearray([0x02, is_on, pattern] + [0x00] * 17)
        await self.write_device_information(ba)

    async def set_led_brightness(self, brightness):
        &#34;&#34;&#34;
        引数に明るさ（0-255）をもらい、その値にLEDを設定する。LED輝度の設定以外は変更しないので、一旦 device informationを取得しなおし、LED輝度以外はすべて従来値を使う

        Args:
            brightness: 0-255

        Returns: None
        &#34;&#34;&#34;
        if brightness &lt; 0 or brightness &gt; 255:
            print(&#34;brightness must be 0-255.&#34;)
            return

        di = await self.read_device_information()
        ba = bytearray([0x01, di.lr, brightness, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro] + [0x00] * 11)
        await self.write_device_information(ba)

    async def set_lr(self, lr):
        &#34;&#34;&#34;
        lr(int): 0 or 1
        Returns: None
        &#34;&#34;&#34;
        # lrの値の範囲をチェック
        if lr &lt; 0 or lr &gt; 1:
            print(&#34;lr must be 0 or 1.&#34;)
            return

        di = await self.read_device_information()
        ba = bytearray([0x01, lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro] + [0x00] * 11)
        await self.write_device_information(ba)

    async def set_acc_range(self, acc_range):
        &#34;&#34;&#34;
        acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if acc_range != 2 and acc_range != 4 and acc_range != 8 and acc_range != 16:
            print(&#34;acc_range must be 2, 4, 8, or 16[g].&#34;)
            return

        # acc_range を 0,1,2,3 に変換
        acc_range = [2, 4, 8, 16].index(acc_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.acc = acc_range

        # デバイス情報を書き込む
        ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
        await self.write_device_information(ba)

    async def set_gyro_range(self, gyro_range):
        &#34;&#34;&#34;
        gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if gyro_range != 250 and gyro_range != 500 and gyro_range != 1000 and gyro_range != 2000:
            print(&#34;gyro_range must be 250, 500, 1000, or 2000[deg/s].&#34;)
            return

        # gyro_range を 0,1,2,3 に変換
        gyro_range = [250, 500, 1000, 2000].index(gyro_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.gyro = gyro_range

        # デバイス情報を書き込む
        ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
        await self.write_device_information(ba)

    async def write_device_information(self, ba):
        &#34;&#34;&#34;
        デバイス情報を書き込む。書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ
        &#34;&#34;&#34;
        # print(f&#34;Writing device information: {ba}&#34;)
        await self.client.write_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID, ba)

        # 100ms待つ（これがないと即座にdevice informationを読み込まれると正しいデータ取得ができないため）
        await asyncio.sleep(WRITE_WAIT_INTERVAL_SEC)

    async def sensor_values_notification_handler(self, sender, data):
        &#34;&#34;&#34;
        センサの値を取得したときに呼び出されるハンドラ
        &#34;&#34;&#34;
        if (self.is_connected() == False):
            return

        # データの長さを確認
        if data[0] == 50:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)
            if (sensor_values.serial_number - self.serial_number_prev) &gt; 1:
                # データ欠損の場合
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(self, &#39;lost_data_callback&#39;) and self.lost_data_callback:
                    self.lost_data_callback(
                        self.serial_number_prev, sensor_values.serial_number)
            self.serial_number_prev = sensor_values.serial_number
        elif data[0] == 40:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)

    async def start_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する
        &#34;&#34;&#34;
        await self.read_device_information()
        await self.client.start_notify(CHARACTERISTIC_SENSOR_VALUES_UUID, self.sensor_values_notification_handler)

    async def step_analysis_notification_handler(self, sender, data):
        &#34;&#34;&#34;
        ステップ解析の値を取得したときに呼び出されるハンドラ
        &#34;&#34;&#34;
        # print(f&#34;Step analysis: {data[1]}&#34;)
        StepAnalysisData(self, data)

    async def start_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を開始する
        &#34;&#34;&#34;
        await self.client.start_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID, self.step_analysis_notification_handler)

    async def stop_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_SENSOR_VALUES_UUID)

    async def stop_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID)

    async def disconnect(self):
        &#34;&#34;&#34;
        ORPHE COREとの接続を切断する
        &#34;&#34;&#34;
        await self.client.disconnect()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.Orphe.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREと接続する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>接続するデバイスのアドレス。指定しない場合はスキャンしてSERVICE UUIDで合致するものに接続する</dd>
</dl>
<p>Returns:
接続に成功した場合はTrue、失敗した場合はFalse</p></div>
</dd>
<dt id="orphe_core.Orphe.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREとの接続を切断する</p></div>
</dd>
<dt id="orphe_core.Orphe.disconnect_callback"><code class="name flex">
<span>async def <span class="ident">disconnect_callback</span></span>(<span>self, owner)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orphe_core.Orphe.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREに接続されているかどうかを返す</p>
<h2 id="returns">Returns</h2>
<p>接続されている場合はTrue、されていない場合はFalse</p></div>
</dd>
<dt id="orphe_core.Orphe.monitor_connection"><code class="name flex">
<span>async def <span class="ident">monitor_connection</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orphe_core.Orphe.print_device_information"><code class="name flex">
<span>async def <span class="ident">print_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途</p></div>
</dd>
<dt id="orphe_core.Orphe.read_device_information"><code class="name flex">
<span>async def <span class="ident">read_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
Returns: DeviceInformationクラスのインスタンス</p></div>
</dd>
<dt id="orphe_core.Orphe.scan_all_devices"><code class="name flex">
<span>async def <span class="ident">scan_all_devices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>すべてのBLEデバイスをスキャンして、その結果を返す</p>
<h2 id="returns">Returns</h2>
<p>BLEデバイスのリスト</p></div>
</dd>
<dt id="orphe_core.Orphe.sensor_values_notification_handler"><code class="name flex">
<span>async def <span class="ident">sensor_values_notification_handler</span></span>(<span>self, sender, data)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値を取得したときに呼び出されるハンドラ</p></div>
</dd>
<dt id="orphe_core.Orphe.set_acc_range"><code class="name flex">
<span>async def <span class="ident">set_acc_range</span></span>(<span>self, acc_range)</span>
</code></dt>
<dd>
<div class="desc"><p>acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
Returns: None</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_acc_callback"><code class="name flex">
<span>def <span class="ident">set_got_acc_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。</p>
<p>例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_converted_acc_callback"><code class="name flex">
<span>def <span class="ident">set_got_converted_acc_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を取得したときに呼び出されるコールバック関数を設定する</p>
<p>それぞれの値は加速度レンジの値によって変換されます。
例えば静止状態ではz方向の1Gの値は常に1.0です。</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_converted_gyro_callback"><code class="name flex">
<span>def <span class="ident">set_got_converted_gyro_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_gait_callback"><code class="name flex">
<span>def <span class="ident">set_got_gait_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>歩行解析の値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_gyro_callback"><code class="name flex">
<span>def <span class="ident">set_got_gyro_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_pronation_callback"><code class="name flex">
<span>def <span class="ident">set_got_pronation_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>プロネーションの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_quat_callback"><code class="name flex">
<span>def <span class="ident">set_got_quat_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_quat_distance_callback"><code class="name flex">
<span>def <span class="ident">set_got_quat_distance_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンと差分値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_got_stride_callback"><code class="name flex">
<span>def <span class="ident">set_got_stride_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ストライドの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.set_gyro_range"><code class="name flex">
<span>async def <span class="ident">set_gyro_range</span></span>(<span>self, gyro_range)</span>
</code></dt>
<dd>
<div class="desc"><p>gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
Returns: None</p></div>
</dd>
<dt id="orphe_core.Orphe.set_led"><code class="name flex">
<span>async def <span class="ident">set_led</span></span>(<span>self, is_on, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>is_on(int): 0 or 1
pattern(int): 0-4
Returns: None</p></div>
</dd>
<dt id="orphe_core.Orphe.set_led_brightness"><code class="name flex">
<span>async def <span class="ident">set_led_brightness</span></span>(<span>self, brightness)</span>
</code></dt>
<dd>
<div class="desc"><p>引数に明るさ（0-255）をもらい、その値にLEDを設定する。LED輝度の設定以外は変更しないので、一旦 device informationを取得しなおし、LED輝度以外はすべて従来値を使う</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>brightness</code></strong></dt>
<dd>0-255</dd>
</dl>
<p>Returns: None</p></div>
</dd>
<dt id="orphe_core.Orphe.set_lost_data_callback"><code class="name flex">
<span>def <span class="ident">set_lost_data_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>データが欠損したときに呼び出されるコールバック関数を設定する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback</code></strong></dt>
<dd>コールバック関数</dd>
</dl></div>
</dd>
<dt id="orphe_core.Orphe.set_lr"><code class="name flex">
<span>async def <span class="ident">set_lr</span></span>(<span>self, lr)</span>
</code></dt>
<dd>
<div class="desc"><p>lr(int): 0 or 1
Returns: None</p></div>
</dd>
<dt id="orphe_core.Orphe.set_on_disconnect_callback"><code class="name flex">
<span>def <span class="ident">set_on_disconnect_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREとの接続が切断されたときに呼び出されるコールバック関数を設定する</p></div>
</dd>
<dt id="orphe_core.Orphe.start_sensor_values_notification"><code class="name flex">
<span>async def <span class="ident">start_sensor_values_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する</p></div>
</dd>
<dt id="orphe_core.Orphe.start_step_analysis_notification"><code class="name flex">
<span>async def <span class="ident">start_step_analysis_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の通知を開始する</p></div>
</dd>
<dt id="orphe_core.Orphe.step_analysis_notification_handler"><code class="name flex">
<span>async def <span class="ident">step_analysis_notification_handler</span></span>(<span>self, sender, data)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の値を取得したときに呼び出されるハンドラ</p></div>
</dd>
<dt id="orphe_core.Orphe.stop_sensor_values_notification"><code class="name flex">
<span>async def <span class="ident">stop_sensor_values_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値の通知を停止する</p></div>
</dd>
<dt id="orphe_core.Orphe.stop_step_analysis_notification"><code class="name flex">
<span>async def <span class="ident">stop_step_analysis_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の通知を停止する</p></div>
</dd>
<dt id="orphe_core.Orphe.write_device_information"><code class="name flex">
<span>async def <span class="ident">write_device_information</span></span>(<span>self, ba)</span>
</code></dt>
<dd>
<div class="desc"><p>デバイス情報を書き込む。書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ</p></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.PronationData"><code class="flex name class">
<span>class <span class="ident">PronationData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>プロネーションの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>landing_impact</code></strong></dt>
<dd>着地衝撃力</dd>
<dt><strong><code>x</code></strong></dt>
<dd>プロネーションX</dd>
<dt><strong><code>y</code></strong></dt>
<dd>プロネーションY</dd>
<dt><strong><code>z</code></strong></dt>
<dd>プロネーションZ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PronationData:
    &#34;&#34;&#34;
    プロネーションの値を格納するクラス

    Attributes:
        step_count: 歩数
        landing_impact: 着地衝撃力
        x: プロネーションX
        y: プロネーションY
        z: プロネーションZ
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4,5,6,7はfloat32で着地衝撃力[kgf](landing_impact)
        self.landing_impact = struct.unpack(&#39;&gt;f&#39;, data[4:8])
        # 8,9,10,11はプロネーションX[deg](x)
        self.x = struct.unpack(&#39;&gt;f&#39;, data[8:12])
        # 12,13,14,15はプロネーションY[deg](y)
        self.y = struct.unpack(&#39;&gt;f&#39;, data[12:16])
        # 16,17,18,19はプロネーションZ[deg](z)
        self.z = struct.unpack(&#39;&gt;f&#39;, data[16:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Landing impact: {self.landing_impact}&#34;)
        print(f&#34;Pronation X: {self.x}&#34;)
        print(f&#34;Pronation Y: {self.y}&#34;)
        print(f&#34;Pronation Z: {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.PronationData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.QuatData"><code class="flex name class">
<span>class <span class="ident">QuatData</span></span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>w</code></strong></dt>
<dd>w</dd>
<dt><strong><code>x</code></strong></dt>
<dd>x</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuatData:
    &#34;&#34;&#34;
    クォータニオンの値を格納するクラス

    Attributes:
        w: w
        x: x
        y: y
        z: z
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.w = 0
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0

    def print(self):
        print(
            f&#34;Quat[{self.serial_number}][{self.packet_number}][{self.timestamp}]: {self.w}, {self.x}, {self.y}, {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.QuatData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.QuatDistanceData"><code class="flex name class">
<span>class <span class="ident">QuatDistanceData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンと差分値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>phase</code></strong></dt>
<dd>歩容フェイズ</dd>
<dt><strong><code>period</code></strong></dt>
<dd>歩容ピリオド</dd>
<dt><strong><code>event</code></strong></dt>
<dd>歩容イベント</dd>
<dt><strong><code>w</code></strong></dt>
<dd>クォータニオンのw</dd>
<dt><strong><code>x</code></strong></dt>
<dd>クォータニオンのx</dd>
<dt><strong><code>y</code></strong></dt>
<dd>クォータニオンのy</dd>
<dt><strong><code>z</code></strong></dt>
<dd>クォータニオンのz</dd>
<dt><strong><code>x_distance</code></strong></dt>
<dd>加速度力算出された単位時間のx移動距離</dd>
<dt><strong><code>y_distance</code></strong></dt>
<dd>加速度力算出された単位時間のy移動距離</dd>
<dt><strong><code>z_distance</code></strong></dt>
<dd>加速度力算出された単位時間のz移動距離</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuatDistanceData:
    &#34;&#34;&#34;
    クォータニオンと差分値を格納するクラス

    Attributes:
        step_count: 歩数
        phase: 歩容フェイズ
        period: 歩容ピリオド
        event: 歩容イベント
        w: クォータニオンのw
        x: クォータニオンのx
        y: クォータニオンのy
        z: クォータニオンのz
        x_distance: 加速度力算出された単位時間のx移動距離
        y_distance: 加速度力算出された単位時間のy移動距離
        z_distance: 加速度力算出された単位時間のz移動距離
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4は01ビットがenumの歩容フェイズ（0:なし, 1:立脚期, 2:遊脚期）
        self.phase = data[4] &amp; 0b00000001
        # 4は2,3,4ビットがenumの歩容ピリオド（0:なし,1:LoadingResponse, 2:MidStance, 3:TerminalStance, 4:InitialSwing, 5:MidSwing, 6:TerminalSwing）
        self.period = (data[4] &amp; 0b00011110) &gt;&gt; 1
        # 4は5,6,7ビットがenumの歩容イベント(0:なし, 1:InitialContact, 2:FootFlat, 3:HeelRise, 4:ToeOff, 5:FeetAdjacent, 6:TibiaVertical)
        self.event = (data[4] &amp; 0b11100000) &gt;&gt; 5
        # 6,7はfloat16でクォータニオンのw
        self.w = struct.unpack(&#39;&gt;e&#39;, data[6:8])
        # 8,9はfloat16でクォータニオンのx
        self.x = struct.unpack(&#39;&gt;e&#39;, data[8:10])
        # 10,11はfloat16でクォータニオンのy
        self.y = struct.unpack(&#39;&gt;e&#39;, data[10:12])
        # 12,13はfloat16でクォータニオンのz
        self.z = struct.unpack(&#39;&gt;e&#39;, data[12:14])
        # 14,15はfloat16で加速度力算出された単位時間のx移動距離
        self.x_distance = struct.unpack(&#39;&gt;e&#39;, data[14:16])
        # 16,17はfloat16で加速度力算出された単位時間のy移動距離
        self.y_distance = struct.unpack(&#39;&gt;e&#39;, data[16:18])
        # 18,19はfloat16で加速度力算出された単位時間のz移動距離
        self.z_distance = struct.unpack(&#39;&gt;e&#39;, data[18:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Phase: {self.phase}&#34;)
        print(f&#34;Period: {self.period}&#34;)
        print(f&#34;Event: {self.event}&#34;)
        print(f&#34;Quat: {self.w}, {self.x}, {self.y}, {self.z}&#34;)
        print(
            f&#34;Distance: {self.x_distance}, {self.y_distance}, {self.z_distance}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.QuatDistanceData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orphe_core.Range"><code class="flex name class">
<span>class <span class="ident">Range</span></span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサとジャイロセンサのレンジを格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>acc</code></strong></dt>
<dd>加速度センサのレンジ</dd>
<dt><strong><code>gyro</code></strong></dt>
<dd>ジャイロセンサのレンジ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Range:
    &#34;&#34;&#34;
    加速度センサとジャイロセンサのレンジを格納するクラス

    Attributes:
        acc: 加速度センサのレンジ
        gyro: ジャイロセンサのレンジ
    &#34;&#34;&#34;

    def __init__(self):
        self.acc = 0
        self.gyro = 0</code></pre>
</details>
</dd>
<dt id="orphe_core.SensorValuesData"><code class="flex name class">
<span>class <span class="ident">SensorValuesData</span></span>
<span>(</span><span>owner, data, sensor_range)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
<dt><strong><code>type</code></strong></dt>
<dd>タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>acc</code></strong></dt>
<dd>加速度センサの値</dd>
<dt><strong><code>converted_acc</code></strong></dt>
<dd>変換後の加速度センサの値</dd>
<dt><strong><code>gyro</code></strong></dt>
<dd>ジャイロセンサの値</dd>
<dt><strong><code>converted_gyro</code></strong></dt>
<dd>変換後のジャイロセンサの値</dd>
<dt><strong><code>quat</code></strong></dt>
<dd>クォータニオンの値</dd>
</dl>
<p>コンストラクタ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
<dt><strong><code>sensor_range</code></strong></dt>
<dd>加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorValuesData:
    &#34;&#34;&#34;
    センサの値を格納するクラス

    Attributes:
        owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
        data: 生データ
        type: タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）
        serial_number: シリアルナンバー
        timestamp: タイムスタンプ
        acc: 加速度センサの値
        converted_acc: 変換後の加速度センサの値
        gyro: ジャイロセンサの値
        converted_gyro: 変換後のジャイロセンサの値
        quat: クォータニオンの値
    &#34;&#34;&#34;

    def __init__(self, owner, data, sensor_range):
        &#34;&#34;&#34;
        コンストラクタ

        Args:
            owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
            data: 生データ
            sensor_range: 加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス
            &#34;&#34;&#34;
        if data[0] == 50:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.serial_number = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = to_timestamp(
                data[3], data[4], data[5], data[6], data[7])
            each_timestamp = self.timestamp

            for i in range(3, -1, -1):
                step = 21*i
                self.acc = AccData()
                self.acc.x = int.from_bytes(
                    data[22+step:24+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.y = int.from_bytes(
                    data[24+step:26+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.z = int.from_bytes(
                    data[26+step:28+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_acc = AccData()
                amp_acc = [2, 4, 8, 16][sensor_range.acc]
                self.converted_acc.x = self.acc.x * amp_acc
                self.converted_acc.y = self.acc.y * amp_acc
                self.converted_acc.z = self.acc.z * amp_acc

                self.gyro = GyroData()
                self.gyro.x = int.from_bytes(
                    data[16+step:18+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.y = int.from_bytes(
                    data[18+step:20+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.z = int.from_bytes(
                    data[20+step:22+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_gyro = GyroData()
                amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
                self.converted_gyro.x = self.gyro.x * amp_gyro
                self.converted_gyro.y = self.gyro.y * amp_gyro
                self.converted_gyro.z = self.gyro.z * amp_gyro

                self.quat = QuatData()
                self.quat.w = int.from_bytes(
                    data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.x = int.from_bytes(
                    data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.y = int.from_bytes(
                    data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.z = int.from_bytes(
                    data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.acc.serial_number = self.serial_number
                self.converted_acc.serial_number = self.serial_number
                self.gyro.serial_number = self.serial_number
                self.converted_gyro.serial_number = self.serial_number
                self.quat.serial_number = self.serial_number
                self.acc.packet_number = 3-i
                self.converted_acc.packet_number = 3-i
                self.gyro.packet_number = 3-i
                self.converted_gyro.packet_number = 3-i
                self.quat.packet_number = 3-i

                if i == 3:
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp
                else:
                    each_timestamp = each_timestamp + data[28+step]
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp

                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
                    owner.got_acc_callback(self.acc)
                if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
                    owner.got_converted_acc_callback(self.converted_acc)
                if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
                    owner.got_gyro_callback(self.gyro)
                if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
                    owner.got_converted_gyro_callback(self.converted_gyro)
                if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
                    owner.got_quat_callback(self.quat)

        elif data[0] == 40:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = int.from_bytes(
                data[18:20], byteorder=&#39;big&#39;, signed=False)

            self.acc = AccData()
            self.acc.x = int.from_bytes(
                data[14:15], byteorder=&#39;big&#39;, signed=True)/127
            self.acc.y = int.from_bytes(
                data[15:16], byteorder=&#39;big&#39;, signed=True)/127
            self.acc.z = int.from_bytes(
                data[16:17], byteorder=&#39;big&#39;, signed=True)/127

            self.converted_acc = AccData()
            amp_acc = [2, 4, 8, 16][sensor_range.acc]
            self.converted_acc.x = self.acc.x * amp_acc
            self.converted_acc.y = self.acc.y * amp_acc
            self.converted_acc.z = self.acc.z * amp_acc

            self.gyro = GyroData()
            self.gyro.x = int.from_bytes(
                data[9:10], byteorder=&#39;big&#39;, signed=True)/127
            self.gyro.y = int.from_bytes(
                data[10:11], byteorder=&#39;big&#39;, signed=True)/127
            self.gyro.z = int.from_bytes(
                data[11:12], byteorder=&#39;big&#39;, signed=True)/127

            self.converted_gyro = GyroData()
            amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
            self.converted_gyro.x = self.gyro.x * amp_gyro
            self.converted_gyro.y = self.gyro.y * amp_gyro
            self.converted_gyro.z = self.gyro.z * amp_gyro

            self.quat = QuatData()
            self.quat.w = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.x = int.from_bytes(
                data[3:5], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.y = int.from_bytes(
                data[5:7], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.z = int.from_bytes(
                data[7:9], byteorder=&#39;big&#39;, signed=True) / 32768

            self.acc.serial_number = 0
            self.converted_acc.serial_number = 0
            self.gyro.serial_number = 0
            self.converted_gyro.serial_number = 0
            self.quat.serial_number = 0
            self.acc.packet_number = 0
            self.converted_acc.packet_number = 0
            self.gyro.packet_number = 0
            self.converted_gyro.packet_number = 0
            self.quat.packet_number = 0

            self.acc.timestamp = self.timestamp
            self.gyro.timestamp = self.timestamp
            self.quat.timestamp = self.timestamp
            self.converted_acc.timestamp = self.timestamp
            self.converted_gyro.timestamp = self.timestamp

            # コールバック関数が設定されている場合、コールバック関数を呼び出す
            if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
                owner.got_acc_callback(self.acc)
            if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
                owner.got_converted_acc_callback(self.converted_acc)
            if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
                owner.got_gyro_callback(self.gyro)
            if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
                owner.got_converted_gyro_callback(self.converted_gyro)
            if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
                owner.got_quat_callback(self.quat)</code></pre>
</details>
</dd>
<dt id="orphe_core.StepAnalysisData"><code class="flex name class">
<span>class <span class="ident">StepAnalysisData</span></span>
<span>(</span><span>owner, data)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の値を格納するクラス</p>
<p>コンストラクタ</p>
<p>data[1]のサブヘッダによって解析データの種類がわかる。対応するのは、0,1,2,3,4 である。また、0,1,2,3 に関してはデータ到着担保のために同じデータが二回連続で送信されてくるため、歩数カウントで更新すべきデータかどうかを判断する必要がある。</p>
<p>0: Gait Overview
1: Stride
2: Pronation
3: 未実装
4: クオータニオン
5: 未実装
6: 未実装</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（StepAnalysisDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StepAnalysisData:
    &#34;&#34;&#34;
    ステップ解析の値を格納するクラス
    &#34;&#34;&#34;

    def __init__(self, owner, data):
        &#34;&#34;&#34;
        コンストラクタ

        data[1]のサブヘッダによって解析データの種類がわかる。対応するのは、0,1,2,3,4 である。また、0,1,2,3 に関してはデータ到着担保のために同じデータが二回連続で送信されてくるため、歩数カウントで更新すべきデータかどうかを判断する必要がある。

        0: Gait Overview
        1: Stride
        2: Pronation
        3: 未実装
        4: クオータニオン
        5: 未実装
        6: 未実装

        Args:
            owner: オーナー（StepAnalysisDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
            data: 生データ
        &#34;&#34;&#34;
        self.data = data

        # gait overview
        if data[1] == 0:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            if self.step_count &gt; owner.step_count.gait:
                self.gait = GaitData(data)
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_gait_callback&#39;) and owner.got_gait_callback:
                    owner.got_gait_callback(self.gait)
            owner.step_count.gait = self.step_count
        # stride
        elif data[1] == 1:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            if self.step_count &gt; owner.step_count.stride:
                self.stride = StrideData(data)
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_stride_callback&#39;) and owner.got_stride_callback:
                    owner.got_stride_callback(self.stride)
            owner.step_count.stride = self.step_count
        # pronation
        elif data[1] == 2:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            if self.step_count &gt; owner.step_count.pronation:
                self.pronation = PronationData(data)
                # コールバック関数が設定されている場合、コールバック関数を呼び出す
                if hasattr(owner, &#39;got_pronation_callback&#39;) and owner.got_pronation_callback:
                    owner.got_pronation_callback(self.pronation)
            owner.step_count.pronation = self.step_count
        # quaternion
        elif data[1] == 4:
            self.step_count = int.from_bytes(
                data[2:4], byteorder=&#39;big&#39;, signed=False)
            # if self.step_count &gt; owner.step_count.quat:
            self.quat_distance = QuatDistanceData(data)
            # コールバック関数が設定されている場合、コールバック関数を呼び出す
            if hasattr(owner, &#39;got_quat_distance_callback&#39;) and owner.got_quat_distance_callback:
                owner.got_quat_distance_callback(self.quat_distance)
            owner.step_count.quat = self.step_count</code></pre>
</details>
</dd>
<dt id="orphe_core.StepCount"><code class="flex name class">
<span>class <span class="ident">StepCount</span></span>
</code></dt>
<dd>
<div class="desc"><p>歩数を格納するクラス</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StepCount:
    &#34;&#34;&#34;
    歩数を格納するクラス&#34;&#34;&#34;

    def __init__(self):
        self.gait = 0
        self.stride = 0
        self.pronation = 0
        self.quat = 0</code></pre>
</details>
</dd>
<dt id="orphe_core.StrideData"><code class="flex name class">
<span>class <span class="ident">StrideData</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>ストライドの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>step_count</code></strong></dt>
<dd>歩数</dd>
<dt><strong><code>foot_angle</code></strong></dt>
<dd>フットアングル</dd>
<dt><strong><code>x</code></strong></dt>
<dd>ストライドX</dd>
<dt><strong><code>y</code></strong></dt>
<dd>ストライドY</dd>
<dt><strong><code>z</code></strong></dt>
<dd>ストライドZ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrideData:
    &#34;&#34;&#34;
    ストライドの値を格納するクラス

    Attributes:
        step_count: 歩数
        foot_angle: フットアングル
        x: ストライドX
        y: ストライドY
        z: ストライドZ
    &#34;&#34;&#34;

    def __init__(self, data):
        # 2,3は Uint16 で歩数が入っている
        self.step_count = int.from_bytes(
            data[2:4], byteorder=&#39;big&#39;, signed=False)
        # 4,5,6,7はfloat32でフットアングル
        self.foot_angle = struct.unpack(&#39;&gt;f&#39;, data[4:8])
        # 8,9,10,11はfloat32でストライドX
        self.x = struct.unpack(&#39;&gt;f&#39;, data[8:12])
        # 12,13,14,15はfloat32でストライドY
        self.y = struct.unpack(&#39;&gt;f&#39;, data[12:16])
        # 16,17,18,19はfloat32でストライドZ
        self.z = struct.unpack(&#39;&gt;f&#39;, data[16:20])

    def print(self):
        print(f&#34;Step count: {self.step_count}&#34;)
        print(f&#34;Foot angle: {self.foot_angle}&#34;)
        print(f&#34;Stride X: {self.x}&#34;)
        print(f&#34;Stride Y: {self.y}&#34;)
        print(f&#34;Stride Z: {self.z}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.StrideData.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="orphe_core.to_timestamp" href="#orphe_core.to_timestamp">to_timestamp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orphe_core.AccData" href="#orphe_core.AccData">AccData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.AccData.print" href="#orphe_core.AccData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.DeviceInformation" href="#orphe_core.DeviceInformation">DeviceInformation</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.GaitData" href="#orphe_core.GaitData">GaitData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.GaitData.print" href="#orphe_core.GaitData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.GyroData" href="#orphe_core.GyroData">GyroData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.GyroData.print" href="#orphe_core.GyroData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.Orphe" href="#orphe_core.Orphe">Orphe</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.Orphe.connect" href="#orphe_core.Orphe.connect">connect</a></code></li>
<li><code><a title="orphe_core.Orphe.disconnect" href="#orphe_core.Orphe.disconnect">disconnect</a></code></li>
<li><code><a title="orphe_core.Orphe.disconnect_callback" href="#orphe_core.Orphe.disconnect_callback">disconnect_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.is_connected" href="#orphe_core.Orphe.is_connected">is_connected</a></code></li>
<li><code><a title="orphe_core.Orphe.monitor_connection" href="#orphe_core.Orphe.monitor_connection">monitor_connection</a></code></li>
<li><code><a title="orphe_core.Orphe.print_device_information" href="#orphe_core.Orphe.print_device_information">print_device_information</a></code></li>
<li><code><a title="orphe_core.Orphe.read_device_information" href="#orphe_core.Orphe.read_device_information">read_device_information</a></code></li>
<li><code><a title="orphe_core.Orphe.scan_all_devices" href="#orphe_core.Orphe.scan_all_devices">scan_all_devices</a></code></li>
<li><code><a title="orphe_core.Orphe.sensor_values_notification_handler" href="#orphe_core.Orphe.sensor_values_notification_handler">sensor_values_notification_handler</a></code></li>
<li><code><a title="orphe_core.Orphe.set_acc_range" href="#orphe_core.Orphe.set_acc_range">set_acc_range</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_acc_callback" href="#orphe_core.Orphe.set_got_acc_callback">set_got_acc_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_converted_acc_callback" href="#orphe_core.Orphe.set_got_converted_acc_callback">set_got_converted_acc_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_converted_gyro_callback" href="#orphe_core.Orphe.set_got_converted_gyro_callback">set_got_converted_gyro_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_gait_callback" href="#orphe_core.Orphe.set_got_gait_callback">set_got_gait_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_gyro_callback" href="#orphe_core.Orphe.set_got_gyro_callback">set_got_gyro_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_pronation_callback" href="#orphe_core.Orphe.set_got_pronation_callback">set_got_pronation_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_quat_callback" href="#orphe_core.Orphe.set_got_quat_callback">set_got_quat_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_quat_distance_callback" href="#orphe_core.Orphe.set_got_quat_distance_callback">set_got_quat_distance_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_stride_callback" href="#orphe_core.Orphe.set_got_stride_callback">set_got_stride_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_gyro_range" href="#orphe_core.Orphe.set_gyro_range">set_gyro_range</a></code></li>
<li><code><a title="orphe_core.Orphe.set_led" href="#orphe_core.Orphe.set_led">set_led</a></code></li>
<li><code><a title="orphe_core.Orphe.set_led_brightness" href="#orphe_core.Orphe.set_led_brightness">set_led_brightness</a></code></li>
<li><code><a title="orphe_core.Orphe.set_lost_data_callback" href="#orphe_core.Orphe.set_lost_data_callback">set_lost_data_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_lr" href="#orphe_core.Orphe.set_lr">set_lr</a></code></li>
<li><code><a title="orphe_core.Orphe.set_on_disconnect_callback" href="#orphe_core.Orphe.set_on_disconnect_callback">set_on_disconnect_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.start_sensor_values_notification" href="#orphe_core.Orphe.start_sensor_values_notification">start_sensor_values_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.start_step_analysis_notification" href="#orphe_core.Orphe.start_step_analysis_notification">start_step_analysis_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.step_analysis_notification_handler" href="#orphe_core.Orphe.step_analysis_notification_handler">step_analysis_notification_handler</a></code></li>
<li><code><a title="orphe_core.Orphe.stop_sensor_values_notification" href="#orphe_core.Orphe.stop_sensor_values_notification">stop_sensor_values_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.stop_step_analysis_notification" href="#orphe_core.Orphe.stop_step_analysis_notification">stop_step_analysis_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.write_device_information" href="#orphe_core.Orphe.write_device_information">write_device_information</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.PronationData" href="#orphe_core.PronationData">PronationData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.PronationData.print" href="#orphe_core.PronationData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.QuatData" href="#orphe_core.QuatData">QuatData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.QuatData.print" href="#orphe_core.QuatData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.QuatDistanceData" href="#orphe_core.QuatDistanceData">QuatDistanceData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.QuatDistanceData.print" href="#orphe_core.QuatDistanceData.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.Range" href="#orphe_core.Range">Range</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.SensorValuesData" href="#orphe_core.SensorValuesData">SensorValuesData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.StepAnalysisData" href="#orphe_core.StepAnalysisData">StepAnalysisData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.StepCount" href="#orphe_core.StepCount">StepCount</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.StrideData" href="#orphe_core.StrideData">StrideData</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.StrideData.print" href="#orphe_core.StrideData.print">print</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
