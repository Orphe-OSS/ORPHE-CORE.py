<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orphe_core API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orphe_core</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
from datetime import datetime, timedelta
from bleak import BleakClient, BleakScanner


# キャラクタリスティックUUID
CHARACTERISTIC_SENSOR_VALUES_UUID = &#34;f3f9c7ce-46ee-4205-89ac-abe64e626c0f&#34;
CHARACTERISTIC_STEP_ANALYSIS_UUID = &#34;f3f9c7ce-46ee-4205-89ac-abe64e626c0f&#34;
CHARACTERISTIC_DEVICE_INFORMATION_UUID = &#34;24354f22-1c46-430e-a4ab-a1eeabbcdfc0&#34;
# デバイスのサービスUUID（例：OrpheのサービスUUID）
SERVICE_ORPHE_INFORMATION_UUID = &#34;01a9d6b5-ff6e-444a-b266-0be75e85c064&#34;
SERVICE_OTHER_UUID = &#34;01a9d6b5-ff6e-444a-b266-0be75e85c064&#34;

WRITE_WAIT_INTERVAL_SEC = 0.2


def to_timestamp(hours, minutes, seconds, ms_high, ms_low):
    &#34;&#34;&#34;
    v3のデータについてくるタイムスタンプをフォーマットする関数

    Args:
        hours: 時
        minutes: 分
        seconds: 秒
        ms_high: ミリ秒の上位バイト
        ms_low: ミリ秒の下位バイト
    &#34;&#34;&#34;
    # 現在の日付を取得
    now = datetime.now()

    # ミリ秒を上位バイトと下位バイトから計算
    milliseconds = (ms_high &lt;&lt; 8) | ms_low

    # 日付を置き換えて、新しいdatetimeオブジェクトを作成
    dt = now.replace(hour=hours, minute=minutes, second=seconds,
                     microsecond=milliseconds * 1000)

    # UNIXタイムスタンプを返す（MSまで含めた整数）
    return int(dt.timestamp()*1000)


class AccData:
    &#34;&#34;&#34;
    加速度センサの値を格納するクラス

    Attributes:
        x: x軸の加速度
        y: y軸の加速度
        z: z軸の加速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0


class GyroData:
    &#34;&#34;&#34;
    ジャイロセンサの値を格納するクラス

    Attributes:
        x: x軸の角速度
        y: y軸の角速度
        z: z軸の角速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0


class QuatData:
    &#34;&#34;&#34;
    クォータニオンの値を格納するクラス

    Attributes:
        w: w
        x: x
        y: y
        z: z
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.w = 0
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0


class Range:
    &#34;&#34;&#34;
    加速度センサとジャイロセンサのレンジを格納するクラス

    Attributes:
        acc: 加速度センサのレンジ
        gyro: ジャイロセンサのレンジ
    &#34;&#34;&#34;

    def __init__(self):
        self.acc = 0
        self.gyro = 0


class SensorValuesData:
    &#34;&#34;&#34;
    センサの値を格納するクラス

    Attributes:
        owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
        data: 生データ
        type: タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）
        serial_number: シリアルナンバー
        timestamp: タイムスタンプ
        acc: 加速度センサの値
        converted_acc: 変換後の加速度センサの値
        gyro: ジャイロセンサの値
        converted_gyro: 変換後のジャイロセンサの値
        quat: クォータニオンの値
    &#34;&#34;&#34;

    def __init__(self, owner, data, sensor_range):
        &#34;&#34;&#34;
        コンストラクタ

        Args:
            owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
            data: 生データ
            sensor_range: 加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス
            &#34;&#34;&#34;
        if data[0] == 50:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.serial_number = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = to_timestamp(
                data[3], data[4], data[5], data[6], data[7])
            each_timestamp = self.timestamp

            for i in range(3, -1, -1):
                step = 21*i
                self.acc = AccData()
                self.acc.x = int.from_bytes(
                    data[22+step:24+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.y = int.from_bytes(
                    data[24+step:26+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.z = int.from_bytes(
                    data[26+step:28+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_acc = AccData()
                amp_acc = [2, 4, 8, 16][sensor_range.acc]
                self.converted_acc.x = self.acc.x * amp_acc
                self.converted_acc.y = self.acc.y * amp_acc
                self.converted_acc.z = self.acc.z * amp_acc

                self.gyro = GyroData()
                self.gyro.x = int.from_bytes(
                    data[16+step:18+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.y = int.from_bytes(
                    data[18+step:20+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.z = int.from_bytes(
                    data[20+step:22+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_gyro = GyroData()
                amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
                self.converted_gyro.x = self.gyro.x * amp_gyro
                self.converted_gyro.y = self.gyro.y * amp_gyro
                self.converted_gyro.z = self.gyro.z * amp_gyro

                self.quat = QuatData()
                self.quat.w = int.from_bytes(
                    data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.x = int.from_bytes(
                    data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.y = int.from_bytes(
                    data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.z = int.from_bytes(
                    data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.acc.serial_number = self.serial_number
                self.converted_acc.serial_number = self.serial_number
                self.gyro.serial_number = self.serial_number
                self.converted_gyro.serial_number = self.serial_number
                self.quat.serial_number = self.serial_number
                self.acc.packet_number = 3-i
                self.converted_acc.packet_number = 3-i
                self.gyro.packet_number = 3-i
                self.converted_gyro.packet_number = 3-i
                self.quat.packet_number = 3-i

                if i == 3:
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp
                else:
                    each_timestamp = each_timestamp + data[28+step]
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp

        elif data[0] == 40:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = int.from_bytes(
                data[18:20], byteorder=&#39;big&#39;, signed=False)

            self.acc = AccData()
            self.acc.x = int.from_bytes(
                data[14:15], byteorder=&#39;big&#39;, signed=True)/127
            self.acc.y = int.from_bytes(
                data[15:16], byteorder=&#39;big&#39;, signed=True)/127
            self.acc.z = int.from_bytes(
                data[16:17], byteorder=&#39;big&#39;, signed=True)/127

            self.converted_acc = AccData()
            amp_acc = [2, 4, 8, 16][sensor_range.acc]
            self.converted_acc.x = self.acc.x * amp_acc
            self.converted_acc.y = self.acc.y * amp_acc
            self.converted_acc.z = self.acc.z * amp_acc

            self.gyro = GyroData()
            self.gyro.x = int.from_bytes(
                data[9:10], byteorder=&#39;big&#39;, signed=True)/127
            self.gyro.y = int.from_bytes(
                data[10:11], byteorder=&#39;big&#39;, signed=True)/127
            self.gyro.z = int.from_bytes(
                data[11:12], byteorder=&#39;big&#39;, signed=True)/127

            self.converted_gyro = GyroData()
            amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
            self.converted_gyro.x = self.gyro.x * amp_gyro
            self.converted_gyro.y = self.gyro.y * amp_gyro
            self.converted_gyro.z = self.gyro.z * amp_gyro

            self.quat = QuatData()
            self.quat.w = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.x = int.from_bytes(
                data[3:5], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.y = int.from_bytes(
                data[5:7], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.z = int.from_bytes(
                data[7:9], byteorder=&#39;big&#39;, signed=True) / 32768

            self.acc.serial_number = 0
            self.converted_acc.serial_number = 0
            self.gyro.serial_number = 0
            self.converted_gyro.serial_number = 0
            self.quat.serial_number = 0
            self.acc.packet_number = 0
            self.converted_acc.packet_number = 0
            self.gyro.packet_number = 0
            self.converted_gyro.packet_number = 0
            self.quat.packet_number = 0

            self.acc.timestamp = self.timestamp
            self.gyro.timestamp = self.timestamp
            self.quat.timestamp = self.timestamp
            self.converted_acc.timestamp = self.timestamp
            self.converted_gyro.timestamp = self.timestamp

        # コールバック関数が設定されている場合、コールバック関数を呼び出す
        if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
            owner.got_acc_callback(self.acc)
        if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
            owner.got_converted_acc_callback(self.converted_acc)
        if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
            owner.got_gyro_callback(self.gyro)
        if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
            owner.got_converted_gyro_callback(self.converted_gyro)
        if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
            owner.got_quat_callback(self.quat)


class DeviceInformation:
    &#34;&#34;&#34;
    デバイス情報を格納するクラス
    data: 生データ
    battery: バッテリー残量
    lr: LR
    rec: REC
    auto_run: Auto Run
    led(int): LED発光の強さ 0-255
    log_high: Log High
    log_low: Log Low
    range: レンジ
    device_information: 取得したデバイス情報の保管用メンバ変数
    &#34;&#34;&#34;

    def __init__(self, data):
        self.data = data
        self.battery = int.from_bytes(data[0:1], byteorder=&#39;big&#39;, signed=False)
        self.lr = int.from_bytes(data[1:2], byteorder=&#39;big&#39;, signed=False)
        self.rec = int.from_bytes(data[2:3], byteorder=&#39;big&#39;, signed=False)
        self.auto_run = int.from_bytes(
            data[3:4], byteorder=&#39;big&#39;, signed=False)
        self.led = int.from_bytes(data[4:5], byteorder=&#39;big&#39;, signed=False)
        self.log_high = int.from_bytes(
            data[6:7], byteorder=&#39;big&#39;, signed=False)
        self.log_low = int.from_bytes(data[7:8], byteorder=&#39;big&#39;, signed=False)
        self.range = Range()
        self.range.acc = int.from_bytes(
            data[8:9], byteorder=&#39;big&#39;, signed=False)
        self.range.gyro = int.from_bytes(
            data[9:10], byteorder=&#39;big&#39;, signed=False)
        self.device_information = None


class Orphe:
    &#34;&#34;&#34;
    ORPHE COREのBLE通信を行うクラス
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        コンストラクタ
        &#34;&#34;&#34;
        self.serial_number_prev = 0
        self.client = None

    def set_got_acc_callback(self, callback):
        &#34;&#34;&#34;加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。

        例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。
        &#34;&#34;&#34;
        self.got_acc_callback = callback

    def set_got_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_gyro_callback = callback

    def set_got_converted_acc_callback(self, callback):
        &#34;&#34;&#34;
        加速度センサの値を取得したときに呼び出されるコールバック関数を設定する

        それぞれの値は加速度レンジの値によって変換されます。
        例えば静止状態ではz方向の1Gの値は常に1.0です。
        &#34;&#34;&#34;
        self.got_converted_acc_callback = callback

    def set_got_converted_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_converted_gyro_callback = callback

    def set_got_quat_callback(self, callback):
        &#34;&#34;&#34;
        クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_quat_callback = callback

    async def connect(self):
        &#34;&#34;&#34;
        ORPHE COREと接続する

        Returns: 
            接続に成功した場合はTrue、失敗した場合はFalse
        &#34;&#34;&#34;
        print(&#34;Scanning for ORPHE CORE BLE device...&#34;)
        devices = await BleakScanner.discover()

        target_device = None
        for device in devices:
            if SERVICE_ORPHE_INFORMATION_UUID.lower() in [uuid.lower() for uuid in device.metadata.get(&#34;uuids&#34;, [])]:
                target_device = device
                print(f&#34;Found target device: {device.name}, {device.address}&#34;)
                break

        if target_device is None:
            print(&#34;Target device not found.&#34;)
            return False

        self.client = BleakClient(target_device.address)
        await self.client.connect()
        if await self.client.is_connected():
            print(&#34;Connected to the device&#34;)
            return True
        else:
            print(&#34;Failed to connect to the device&#34;)
            return False

    async def read_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
        Returns: DeviceInformationクラスのインスタンス
        &#34;&#34;&#34;
        di = await self.client.read_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID)
        di = DeviceInformation(di)
        self.device_information = di  # デバイス情報をメンバ変数として保存（更新）しておく
        return di

    async def print_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途
        &#34;&#34;&#34;
        di = await self.read_device_information()
        print(di.rec)
        print(f&#34;Battery: {di.battery}&#34;)
        print(f&#34;LR: {di.lr}&#34;)
        print(f&#34;REC: {di.rec}&#34;)
        print(f&#34;Auto Run: {di.auto_run}&#34;)
        print(f&#34;LED: {di.led}&#34;)
        print(f&#34;Log High: {di.log_high}&#34;)
        print(f&#34;Log Low: {di.log_low}&#34;)
        print(f&#34;ACC Range: {di.range.acc}&#34;)
        print(f&#34;GYRO Range: {di.range.gyro}&#34;)

    async def set_led(self, is_on, pattern):
        &#34;&#34;&#34;
        is_on(int): 0 or 1
        pattern(int): 0-4
        Returns: None
        &#34;&#34;&#34;
        print(f&#34;Setting LED: {is_on}, {pattern}&#34;)
        # is_on, patternの値の範囲をチェック
        if is_on &lt; 0 or is_on &gt; 1:
            print(&#34;is_on must be 0 or 1.&#34;)
            return
        if pattern &lt; 0 or pattern &gt; 4:
            print(&#34;pattern must be 0-4.&#34;)
            return

        ba = bytearray([0x02, is_on, pattern] + [0x00] * 17)
        await self.write_device_information(ba)

    async def set_acc_range(self, acc_range):
        &#34;&#34;&#34;
        acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if acc_range != 2 and acc_range != 4 and acc_range != 8 and acc_range != 16:
            print(&#34;acc_range must be 2, 4, 8, or 16[g].&#34;)
            return

        # acc_range を 0,1,2,3 に変換
        acc_range = [2, 4, 8, 16].index(acc_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.acc = acc_range

        # デバイス情報を書き込む
        ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
        await self.write_device_information(ba)

    async def set_gyro_range(self, gyro_range):
        &#34;&#34;&#34;
        gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if gyro_range != 250 and gyro_range != 500 and gyro_range != 1000 and gyro_range != 2000:
            print(&#34;gyro_range must be 250, 500, 1000, or 2000[deg/s].&#34;)
            return

        # gyro_range を 0,1,2,3 に変換
        gyro_range = [250, 500, 1000, 2000].index(gyro_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.gyro = gyro_range

        # デバイス情報を書き込む
        ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
        await self.write_device_information(ba)

    async def write_device_information(self, ba):
        &#34;&#34;&#34;
        デバイス情報を書き込む。書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ
        &#34;&#34;&#34;
        print(f&#34;Writing device information: {ba}&#34;)
        await self.client.write_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID, ba)

        # 100ms待つ（これがないと即座にdevice informationを読み込まれると正しいデータ取得ができないため）
        await asyncio.sleep(WRITE_WAIT_INTERVAL_SEC)

    async def sensor_values_notification_handler(self, sender, data):
        &#34;&#34;&#34;
        センサの値を取得したときに呼び出されるハンドラ
        &#34;&#34;&#34;
        # データの長さを確認
        if data[0] == 50:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)
            if (sensor_values.serial_number - self.serial_number_prev) != 1:
                # データ欠損の場合
                print(
                    f&#34;Data loss detected. {self.serial_number_prev} &lt;-&gt; {sensor_values.serial_number}&#34;)
            self.serial_number_prev = sensor_values.serial_number
        elif data[0] == 40:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)

    async def start_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する
        &#34;&#34;&#34;
        await self.read_device_information()
        await self.client.start_notify(CHARACTERISTIC_SENSOR_VALUES_UUID, self.sensor_values_notification_handler)

    async def start_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を開始する
        &#34;&#34;&#34;
        await self.client.start_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID, self.step_analysis_notification_handler)

    async def stop_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_SENSOR_VALUES_UUID)

    async def stop_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID)

    async def disconnect(self):
        &#34;&#34;&#34;
        ORPHE COREとの接続を切断する
        &#34;&#34;&#34;
        await self.client.disconnect()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="orphe_core.to_timestamp"><code class="name flex">
<span>def <span class="ident">to_timestamp</span></span>(<span>hours, minutes, seconds, ms_high, ms_low)</span>
</code></dt>
<dd>
<div class="desc"><p>v3のデータについてくるタイムスタンプをフォーマットする関数</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hours</code></strong></dt>
<dd>時</dd>
<dt><strong><code>minutes</code></strong></dt>
<dd>分</dd>
<dt><strong><code>seconds</code></strong></dt>
<dd>秒</dd>
<dt><strong><code>ms_high</code></strong></dt>
<dd>ミリ秒の上位バイト</dd>
<dt><strong><code>ms_low</code></strong></dt>
<dd>ミリ秒の下位バイト</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_timestamp(hours, minutes, seconds, ms_high, ms_low):
    &#34;&#34;&#34;
    v3のデータについてくるタイムスタンプをフォーマットする関数

    Args:
        hours: 時
        minutes: 分
        seconds: 秒
        ms_high: ミリ秒の上位バイト
        ms_low: ミリ秒の下位バイト
    &#34;&#34;&#34;
    # 現在の日付を取得
    now = datetime.now()

    # ミリ秒を上位バイトと下位バイトから計算
    milliseconds = (ms_high &lt;&lt; 8) | ms_low

    # 日付を置き換えて、新しいdatetimeオブジェクトを作成
    dt = now.replace(hour=hours, minute=minutes, second=seconds,
                     microsecond=milliseconds * 1000)

    # UNIXタイムスタンプを返す（MSまで含めた整数）
    return int(dt.timestamp()*1000)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orphe_core.AccData"><code class="flex name class">
<span>class <span class="ident">AccData</span></span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>x軸の加速度</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y軸の加速度</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z軸の加速度</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccData:
    &#34;&#34;&#34;
    加速度センサの値を格納するクラス

    Attributes:
        x: x軸の加速度
        y: y軸の加速度
        z: z軸の加速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0</code></pre>
</details>
</dd>
<dt id="orphe_core.DeviceInformation"><code class="flex name class">
<span>class <span class="ident">DeviceInformation</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>デバイス情報を格納するクラス
data: 生データ
battery: バッテリー残量
lr: LR
rec: REC
auto_run: Auto Run
led(int): LED発光の強さ 0-255
log_high: Log High
log_low: Log Low
range: レンジ
device_information: 取得したデバイス情報の保管用メンバ変数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceInformation:
    &#34;&#34;&#34;
    デバイス情報を格納するクラス
    data: 生データ
    battery: バッテリー残量
    lr: LR
    rec: REC
    auto_run: Auto Run
    led(int): LED発光の強さ 0-255
    log_high: Log High
    log_low: Log Low
    range: レンジ
    device_information: 取得したデバイス情報の保管用メンバ変数
    &#34;&#34;&#34;

    def __init__(self, data):
        self.data = data
        self.battery = int.from_bytes(data[0:1], byteorder=&#39;big&#39;, signed=False)
        self.lr = int.from_bytes(data[1:2], byteorder=&#39;big&#39;, signed=False)
        self.rec = int.from_bytes(data[2:3], byteorder=&#39;big&#39;, signed=False)
        self.auto_run = int.from_bytes(
            data[3:4], byteorder=&#39;big&#39;, signed=False)
        self.led = int.from_bytes(data[4:5], byteorder=&#39;big&#39;, signed=False)
        self.log_high = int.from_bytes(
            data[6:7], byteorder=&#39;big&#39;, signed=False)
        self.log_low = int.from_bytes(data[7:8], byteorder=&#39;big&#39;, signed=False)
        self.range = Range()
        self.range.acc = int.from_bytes(
            data[8:9], byteorder=&#39;big&#39;, signed=False)
        self.range.gyro = int.from_bytes(
            data[9:10], byteorder=&#39;big&#39;, signed=False)
        self.device_information = None</code></pre>
</details>
</dd>
<dt id="orphe_core.GyroData"><code class="flex name class">
<span>class <span class="ident">GyroData</span></span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>x軸の角速度</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y軸の角速度</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z軸の角速度</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GyroData:
    &#34;&#34;&#34;
    ジャイロセンサの値を格納するクラス

    Attributes:
        x: x軸の角速度
        y: y軸の角速度
        z: z軸の角速度
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe"><code class="flex name class">
<span>class <span class="ident">Orphe</span></span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのBLE通信を行うクラス</p>
<p>コンストラクタ</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orphe:
    &#34;&#34;&#34;
    ORPHE COREのBLE通信を行うクラス
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        コンストラクタ
        &#34;&#34;&#34;
        self.serial_number_prev = 0
        self.client = None

    def set_got_acc_callback(self, callback):
        &#34;&#34;&#34;加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。

        例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。
        &#34;&#34;&#34;
        self.got_acc_callback = callback

    def set_got_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_gyro_callback = callback

    def set_got_converted_acc_callback(self, callback):
        &#34;&#34;&#34;
        加速度センサの値を取得したときに呼び出されるコールバック関数を設定する

        それぞれの値は加速度レンジの値によって変換されます。
        例えば静止状態ではz方向の1Gの値は常に1.0です。
        &#34;&#34;&#34;
        self.got_converted_acc_callback = callback

    def set_got_converted_gyro_callback(self, callback):
        &#34;&#34;&#34;
        ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_converted_gyro_callback = callback

    def set_got_quat_callback(self, callback):
        &#34;&#34;&#34;
        クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する
        &#34;&#34;&#34;
        self.got_quat_callback = callback

    async def connect(self):
        &#34;&#34;&#34;
        ORPHE COREと接続する

        Returns: 
            接続に成功した場合はTrue、失敗した場合はFalse
        &#34;&#34;&#34;
        print(&#34;Scanning for ORPHE CORE BLE device...&#34;)
        devices = await BleakScanner.discover()

        target_device = None
        for device in devices:
            if SERVICE_ORPHE_INFORMATION_UUID.lower() in [uuid.lower() for uuid in device.metadata.get(&#34;uuids&#34;, [])]:
                target_device = device
                print(f&#34;Found target device: {device.name}, {device.address}&#34;)
                break

        if target_device is None:
            print(&#34;Target device not found.&#34;)
            return False

        self.client = BleakClient(target_device.address)
        await self.client.connect()
        if await self.client.is_connected():
            print(&#34;Connected to the device&#34;)
            return True
        else:
            print(&#34;Failed to connect to the device&#34;)
            return False

    async def read_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
        Returns: DeviceInformationクラスのインスタンス
        &#34;&#34;&#34;
        di = await self.client.read_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID)
        di = DeviceInformation(di)
        self.device_information = di  # デバイス情報をメンバ変数として保存（更新）しておく
        return di

    async def print_device_information(self):
        &#34;&#34;&#34;
        ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途
        &#34;&#34;&#34;
        di = await self.read_device_information()
        print(di.rec)
        print(f&#34;Battery: {di.battery}&#34;)
        print(f&#34;LR: {di.lr}&#34;)
        print(f&#34;REC: {di.rec}&#34;)
        print(f&#34;Auto Run: {di.auto_run}&#34;)
        print(f&#34;LED: {di.led}&#34;)
        print(f&#34;Log High: {di.log_high}&#34;)
        print(f&#34;Log Low: {di.log_low}&#34;)
        print(f&#34;ACC Range: {di.range.acc}&#34;)
        print(f&#34;GYRO Range: {di.range.gyro}&#34;)

    async def set_led(self, is_on, pattern):
        &#34;&#34;&#34;
        is_on(int): 0 or 1
        pattern(int): 0-4
        Returns: None
        &#34;&#34;&#34;
        print(f&#34;Setting LED: {is_on}, {pattern}&#34;)
        # is_on, patternの値の範囲をチェック
        if is_on &lt; 0 or is_on &gt; 1:
            print(&#34;is_on must be 0 or 1.&#34;)
            return
        if pattern &lt; 0 or pattern &gt; 4:
            print(&#34;pattern must be 0-4.&#34;)
            return

        ba = bytearray([0x02, is_on, pattern] + [0x00] * 17)
        await self.write_device_information(ba)

    async def set_acc_range(self, acc_range):
        &#34;&#34;&#34;
        acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if acc_range != 2 and acc_range != 4 and acc_range != 8 and acc_range != 16:
            print(&#34;acc_range must be 2, 4, 8, or 16[g].&#34;)
            return

        # acc_range を 0,1,2,3 に変換
        acc_range = [2, 4, 8, 16].index(acc_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.acc = acc_range

        # デバイス情報を書き込む
        ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
        await self.write_device_information(ba)

    async def set_gyro_range(self, gyro_range):
        &#34;&#34;&#34;
        gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
        Returns: None
        &#34;&#34;&#34;
        # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
        if gyro_range != 250 and gyro_range != 500 and gyro_range != 1000 and gyro_range != 2000:
            print(&#34;gyro_range must be 250, 500, 1000, or 2000[deg/s].&#34;)
            return

        # gyro_range を 0,1,2,3 に変換
        gyro_range = [250, 500, 1000, 2000].index(gyro_range)

        # デバイス情報を読み込む
        di = await self.read_device_information()

        # デバイス情報のレンジ設定を変更
        di.range.gyro = gyro_range

        # デバイス情報を書き込む
        ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                       di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
        await self.write_device_information(ba)

    async def write_device_information(self, ba):
        &#34;&#34;&#34;
        デバイス情報を書き込む。書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ
        &#34;&#34;&#34;
        print(f&#34;Writing device information: {ba}&#34;)
        await self.client.write_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID, ba)

        # 100ms待つ（これがないと即座にdevice informationを読み込まれると正しいデータ取得ができないため）
        await asyncio.sleep(WRITE_WAIT_INTERVAL_SEC)

    async def sensor_values_notification_handler(self, sender, data):
        &#34;&#34;&#34;
        センサの値を取得したときに呼び出されるハンドラ
        &#34;&#34;&#34;
        # データの長さを確認
        if data[0] == 50:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)
            if (sensor_values.serial_number - self.serial_number_prev) != 1:
                # データ欠損の場合
                print(
                    f&#34;Data loss detected. {self.serial_number_prev} &lt;-&gt; {sensor_values.serial_number}&#34;)
            self.serial_number_prev = sensor_values.serial_number
        elif data[0] == 40:
            sensor_values = SensorValuesData(
                self, data, self.device_information.range)

    async def start_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する
        &#34;&#34;&#34;
        await self.read_device_information()
        await self.client.start_notify(CHARACTERISTIC_SENSOR_VALUES_UUID, self.sensor_values_notification_handler)

    async def start_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を開始する
        &#34;&#34;&#34;
        await self.client.start_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID, self.step_analysis_notification_handler)

    async def stop_sensor_values_notification(self):
        &#34;&#34;&#34;
        センサの値の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_SENSOR_VALUES_UUID)

    async def stop_step_analysis_notification(self):
        &#34;&#34;&#34;
        ステップ解析の通知を停止する
        &#34;&#34;&#34;
        await self.client.stop_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID)

    async def disconnect(self):
        &#34;&#34;&#34;
        ORPHE COREとの接続を切断する
        &#34;&#34;&#34;
        await self.client.disconnect()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orphe_core.Orphe.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREと接続する</p>
<p>Returns:
接続に成功した場合はTrue、失敗した場合はFalse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self):
    &#34;&#34;&#34;
    ORPHE COREと接続する

    Returns: 
        接続に成功した場合はTrue、失敗した場合はFalse
    &#34;&#34;&#34;
    print(&#34;Scanning for ORPHE CORE BLE device...&#34;)
    devices = await BleakScanner.discover()

    target_device = None
    for device in devices:
        if SERVICE_ORPHE_INFORMATION_UUID.lower() in [uuid.lower() for uuid in device.metadata.get(&#34;uuids&#34;, [])]:
            target_device = device
            print(f&#34;Found target device: {device.name}, {device.address}&#34;)
            break

    if target_device is None:
        print(&#34;Target device not found.&#34;)
        return False

    self.client = BleakClient(target_device.address)
    await self.client.connect()
    if await self.client.is_connected():
        print(&#34;Connected to the device&#34;)
        return True
    else:
        print(&#34;Failed to connect to the device&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREとの接続を切断する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self):
    &#34;&#34;&#34;
    ORPHE COREとの接続を切断する
    &#34;&#34;&#34;
    await self.client.disconnect()</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.print_device_information"><code class="name flex">
<span>async def <span class="ident">print_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def print_device_information(self):
    &#34;&#34;&#34;
    ORPHE COREのデバイス情報を取得し、標準出力に表示する。ほぼデバッグ用途
    &#34;&#34;&#34;
    di = await self.read_device_information()
    print(di.rec)
    print(f&#34;Battery: {di.battery}&#34;)
    print(f&#34;LR: {di.lr}&#34;)
    print(f&#34;REC: {di.rec}&#34;)
    print(f&#34;Auto Run: {di.auto_run}&#34;)
    print(f&#34;LED: {di.led}&#34;)
    print(f&#34;Log High: {di.log_high}&#34;)
    print(f&#34;Log Low: {di.log_low}&#34;)
    print(f&#34;ACC Range: {di.range.acc}&#34;)
    print(f&#34;GYRO Range: {di.range.gyro}&#34;)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.read_device_information"><code class="name flex">
<span>async def <span class="ident">read_device_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
Returns: DeviceInformationクラスのインスタンス</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read_device_information(self):
    &#34;&#34;&#34;
    ORPHE COREのデバイス情報を取得する。一度取得したデバイス情報はself.device_informationメンバ変数に保存される。
    Returns: DeviceInformationクラスのインスタンス
    &#34;&#34;&#34;
    di = await self.client.read_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID)
    di = DeviceInformation(di)
    self.device_information = di  # デバイス情報をメンバ変数として保存（更新）しておく
    return di</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.sensor_values_notification_handler"><code class="name flex">
<span>async def <span class="ident">sensor_values_notification_handler</span></span>(<span>self, sender, data)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値を取得したときに呼び出されるハンドラ</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sensor_values_notification_handler(self, sender, data):
    &#34;&#34;&#34;
    センサの値を取得したときに呼び出されるハンドラ
    &#34;&#34;&#34;
    # データの長さを確認
    if data[0] == 50:
        sensor_values = SensorValuesData(
            self, data, self.device_information.range)
        if (sensor_values.serial_number - self.serial_number_prev) != 1:
            # データ欠損の場合
            print(
                f&#34;Data loss detected. {self.serial_number_prev} &lt;-&gt; {sensor_values.serial_number}&#34;)
        self.serial_number_prev = sensor_values.serial_number
    elif data[0] == 40:
        sensor_values = SensorValuesData(
            self, data, self.device_information.range)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_acc_range"><code class="name flex">
<span>async def <span class="ident">set_acc_range</span></span>(<span>self, acc_range)</span>
</code></dt>
<dd>
<div class="desc"><p>acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_acc_range(self, acc_range):
    &#34;&#34;&#34;
    acc_range(int): 2,4,8,16G を順番に 0,1,2,3 で指定
    Returns: None
    &#34;&#34;&#34;
    # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
    if acc_range != 2 and acc_range != 4 and acc_range != 8 and acc_range != 16:
        print(&#34;acc_range must be 2, 4, 8, or 16[g].&#34;)
        return

    # acc_range を 0,1,2,3 に変換
    acc_range = [2, 4, 8, 16].index(acc_range)

    # デバイス情報を読み込む
    di = await self.read_device_information()

    # デバイス情報のレンジ設定を変更
    di.range.acc = acc_range

    # デバイス情報を書き込む
    ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                   di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
    await self.write_device_information(ba)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_got_acc_callback"><code class="name flex">
<span>def <span class="ident">set_got_acc_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。</p>
<p>例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_got_acc_callback(self, callback):
    &#34;&#34;&#34;加速度センサの値を取得したときに呼び出されるコールバック関数を設定する。

    例えば静止状態ではz方向の1Gの値はレンジ設定によって変わります。加速度レンジが2であれば 0.5 、16であれば 0.0625 （値は理論値なので誤差が生じます）です。
    &#34;&#34;&#34;
    self.got_acc_callback = callback</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_got_converted_acc_callback"><code class="name flex">
<span>def <span class="ident">set_got_converted_acc_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサの値を取得したときに呼び出されるコールバック関数を設定する</p>
<p>それぞれの値は加速度レンジの値によって変換されます。
例えば静止状態ではz方向の1Gの値は常に1.0です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_got_converted_acc_callback(self, callback):
    &#34;&#34;&#34;
    加速度センサの値を取得したときに呼び出されるコールバック関数を設定する

    それぞれの値は加速度レンジの値によって変換されます。
    例えば静止状態ではz方向の1Gの値は常に1.0です。
    &#34;&#34;&#34;
    self.got_converted_acc_callback = callback</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_got_converted_gyro_callback"><code class="name flex">
<span>def <span class="ident">set_got_converted_gyro_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_got_converted_gyro_callback(self, callback):
    &#34;&#34;&#34;
    ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
    &#34;&#34;&#34;
    self.got_converted_gyro_callback = callback</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_got_gyro_callback"><code class="name flex">
<span>def <span class="ident">set_got_gyro_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_got_gyro_callback(self, callback):
    &#34;&#34;&#34;
    ジャイロセンサの値を取得したときに呼び出されるコールバック関数を設定する
    &#34;&#34;&#34;
    self.got_gyro_callback = callback</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_got_quat_callback"><code class="name flex">
<span>def <span class="ident">set_got_quat_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_got_quat_callback(self, callback):
    &#34;&#34;&#34;
    クォータニオンの値を取得したときに呼び出されるコールバック関数を設定する
    &#34;&#34;&#34;
    self.got_quat_callback = callback</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_gyro_range"><code class="name flex">
<span>async def <span class="ident">set_gyro_range</span></span>(<span>self, gyro_range)</span>
</code></dt>
<dd>
<div class="desc"><p>gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_gyro_range(self, gyro_range):
    &#34;&#34;&#34;
    gyro_range(int): 250,500,1000,2000[deg/s] を順番に 0,1,2,3 で指定
    Returns: None
    &#34;&#34;&#34;
    # acc_rangeの値は2,4,8,16のいずれかなので、チェックする
    if gyro_range != 250 and gyro_range != 500 and gyro_range != 1000 and gyro_range != 2000:
        print(&#34;gyro_range must be 250, 500, 1000, or 2000[deg/s].&#34;)
        return

    # gyro_range を 0,1,2,3 に変換
    gyro_range = [250, 500, 1000, 2000].index(gyro_range)

    # デバイス情報を読み込む
    di = await self.read_device_information()

    # デバイス情報のレンジ設定を変更
    di.range.gyro = gyro_range

    # デバイス情報を書き込む
    ba = bytearray([0x01, di.lr, di.led, 0x00, di.auto_run, di.log_high,
                   di.log_low, di.range.acc, di.range.gyro]+[0x00]*11)
    await self.write_device_information(ba)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.set_led"><code class="name flex">
<span>async def <span class="ident">set_led</span></span>(<span>self, is_on, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>is_on(int): 0 or 1
pattern(int): 0-4
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_led(self, is_on, pattern):
    &#34;&#34;&#34;
    is_on(int): 0 or 1
    pattern(int): 0-4
    Returns: None
    &#34;&#34;&#34;
    print(f&#34;Setting LED: {is_on}, {pattern}&#34;)
    # is_on, patternの値の範囲をチェック
    if is_on &lt; 0 or is_on &gt; 1:
        print(&#34;is_on must be 0 or 1.&#34;)
        return
    if pattern &lt; 0 or pattern &gt; 4:
        print(&#34;pattern must be 0-4.&#34;)
        return

    ba = bytearray([0x02, is_on, pattern] + [0x00] * 17)
    await self.write_device_information(ba)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.start_sensor_values_notification"><code class="name flex">
<span>async def <span class="ident">start_sensor_values_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_sensor_values_notification(self):
    &#34;&#34;&#34;
    センサの値の通知を開始する。ただしセンサ値のレンジを取得しておかないといけないので、最初にデバイス情報を取得する
    &#34;&#34;&#34;
    await self.read_device_information()
    await self.client.start_notify(CHARACTERISTIC_SENSOR_VALUES_UUID, self.sensor_values_notification_handler)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.start_step_analysis_notification"><code class="name flex">
<span>async def <span class="ident">start_step_analysis_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の通知を開始する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_step_analysis_notification(self):
    &#34;&#34;&#34;
    ステップ解析の通知を開始する
    &#34;&#34;&#34;
    await self.client.start_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID, self.step_analysis_notification_handler)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.stop_sensor_values_notification"><code class="name flex">
<span>async def <span class="ident">stop_sensor_values_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値の通知を停止する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stop_sensor_values_notification(self):
    &#34;&#34;&#34;
    センサの値の通知を停止する
    &#34;&#34;&#34;
    await self.client.stop_notify(CHARACTERISTIC_SENSOR_VALUES_UUID)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.stop_step_analysis_notification"><code class="name flex">
<span>async def <span class="ident">stop_step_analysis_notification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ステップ解析の通知を停止する</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stop_step_analysis_notification(self):
    &#34;&#34;&#34;
    ステップ解析の通知を停止する
    &#34;&#34;&#34;
    await self.client.stop_notify(CHARACTERISTIC_STEP_ANALYSIS_UUID)</code></pre>
</details>
</dd>
<dt id="orphe_core.Orphe.write_device_information"><code class="name flex">
<span>async def <span class="ident">write_device_information</span></span>(<span>self, ba)</span>
</code></dt>
<dd>
<div class="desc"><p>デバイス情報を書き込む。書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write_device_information(self, ba):
    &#34;&#34;&#34;
    デバイス情報を書き込む。書き込み後にすぐデバイスインフォメーションを読み込むと正しいデータが取得できないため、WRITE_WAIT_INTERVAL_SEC秒待つ
    &#34;&#34;&#34;
    print(f&#34;Writing device information: {ba}&#34;)
    await self.client.write_gatt_char(CHARACTERISTIC_DEVICE_INFORMATION_UUID, ba)

    # 100ms待つ（これがないと即座にdevice informationを読み込まれると正しいデータ取得ができないため）
    await asyncio.sleep(WRITE_WAIT_INTERVAL_SEC)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="orphe_core.QuatData"><code class="flex name class">
<span>class <span class="ident">QuatData</span></span>
</code></dt>
<dd>
<div class="desc"><p>クォータニオンの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>w</code></strong></dt>
<dd>w</dd>
<dt><strong><code>x</code></strong></dt>
<dd>x</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>packet_number</code></strong></dt>
<dd>パケットナンバー</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuatData:
    &#34;&#34;&#34;
    クォータニオンの値を格納するクラス

    Attributes:
        w: w
        x: x
        y: y
        z: z
        timestamp: タイムスタンプ
        serial_number: シリアルナンバー
        packet_number: パケットナンバー
    &#34;&#34;&#34;

    def __init__(self):
        self.w = 0
        self.x = 0
        self.y = 0
        self.z = 0
        self.timestamp = 0
        self.serial_number = 0
        self.packet_number = 0</code></pre>
</details>
</dd>
<dt id="orphe_core.Range"><code class="flex name class">
<span>class <span class="ident">Range</span></span>
</code></dt>
<dd>
<div class="desc"><p>加速度センサとジャイロセンサのレンジを格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>acc</code></strong></dt>
<dd>加速度センサのレンジ</dd>
<dt><strong><code>gyro</code></strong></dt>
<dd>ジャイロセンサのレンジ</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Range:
    &#34;&#34;&#34;
    加速度センサとジャイロセンサのレンジを格納するクラス

    Attributes:
        acc: 加速度センサのレンジ
        gyro: ジャイロセンサのレンジ
    &#34;&#34;&#34;

    def __init__(self):
        self.acc = 0
        self.gyro = 0</code></pre>
</details>
</dd>
<dt id="orphe_core.SensorValuesData"><code class="flex name class">
<span>class <span class="ident">SensorValuesData</span></span>
<span>(</span><span>owner, data, sensor_range)</span>
</code></dt>
<dd>
<div class="desc"><p>センサの値を格納するクラス</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
<dt><strong><code>type</code></strong></dt>
<dd>タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）</dd>
<dt><strong><code>serial_number</code></strong></dt>
<dd>シリアルナンバー</dd>
<dt><strong><code>timestamp</code></strong></dt>
<dd>タイムスタンプ</dd>
<dt><strong><code>acc</code></strong></dt>
<dd>加速度センサの値</dd>
<dt><strong><code>converted_acc</code></strong></dt>
<dd>変換後の加速度センサの値</dd>
<dt><strong><code>gyro</code></strong></dt>
<dd>ジャイロセンサの値</dd>
<dt><strong><code>converted_gyro</code></strong></dt>
<dd>変換後のジャイロセンサの値</dd>
<dt><strong><code>quat</code></strong></dt>
<dd>クォータニオンの値</dd>
</dl>
<p>コンストラクタ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner</code></strong></dt>
<dd>オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）</dd>
<dt><strong><code>data</code></strong></dt>
<dd>生データ</dd>
<dt><strong><code>sensor_range</code></strong></dt>
<dd>加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorValuesData:
    &#34;&#34;&#34;
    センサの値を格納するクラス

    Attributes:
        owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
        data: 生データ
        type: タイプ（40の場合は50Hzのv2, 50の場合は200Hzのv3）
        serial_number: シリアルナンバー
        timestamp: タイムスタンプ
        acc: 加速度センサの値
        converted_acc: 変換後の加速度センサの値
        gyro: ジャイロセンサの値
        converted_gyro: 変換後のジャイロセンサの値
        quat: クォータニオンの値
    &#34;&#34;&#34;

    def __init__(self, owner, data, sensor_range):
        &#34;&#34;&#34;
        コンストラクタ

        Args:
            owner: オーナー（SensorValuesDataを生成したオブジェクトで、Orpheクラスのインスタンスが入っている。これはコールバック関数を登録するため）
            data: 生データ
            sensor_range: 加速度センサとジャイロセンサのレンジ。Rangeクラスのインスタンス
            &#34;&#34;&#34;
        if data[0] == 50:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.serial_number = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = to_timestamp(
                data[3], data[4], data[5], data[6], data[7])
            each_timestamp = self.timestamp

            for i in range(3, -1, -1):
                step = 21*i
                self.acc = AccData()
                self.acc.x = int.from_bytes(
                    data[22+step:24+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.y = int.from_bytes(
                    data[24+step:26+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.acc.z = int.from_bytes(
                    data[26+step:28+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_acc = AccData()
                amp_acc = [2, 4, 8, 16][sensor_range.acc]
                self.converted_acc.x = self.acc.x * amp_acc
                self.converted_acc.y = self.acc.y * amp_acc
                self.converted_acc.z = self.acc.z * amp_acc

                self.gyro = GyroData()
                self.gyro.x = int.from_bytes(
                    data[16+step:18+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.y = int.from_bytes(
                    data[18+step:20+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.gyro.z = int.from_bytes(
                    data[20+step:22+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.converted_gyro = GyroData()
                amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
                self.converted_gyro.x = self.gyro.x * amp_gyro
                self.converted_gyro.y = self.gyro.y * amp_gyro
                self.converted_gyro.z = self.gyro.z * amp_gyro

                self.quat = QuatData()
                self.quat.w = int.from_bytes(
                    data[8+step:10+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.x = int.from_bytes(
                    data[10+step:12+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.y = int.from_bytes(
                    data[12+step:14+step], byteorder=&#39;big&#39;, signed=True) / 32768
                self.quat.z = int.from_bytes(
                    data[14+step:16+step], byteorder=&#39;big&#39;, signed=True) / 32768

                self.acc.serial_number = self.serial_number
                self.converted_acc.serial_number = self.serial_number
                self.gyro.serial_number = self.serial_number
                self.converted_gyro.serial_number = self.serial_number
                self.quat.serial_number = self.serial_number
                self.acc.packet_number = 3-i
                self.converted_acc.packet_number = 3-i
                self.gyro.packet_number = 3-i
                self.converted_gyro.packet_number = 3-i
                self.quat.packet_number = 3-i

                if i == 3:
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp
                else:
                    each_timestamp = each_timestamp + data[28+step]
                    self.acc.timestamp = each_timestamp
                    self.converted_acc.timestamp = each_timestamp
                    self.gyro.timestamp = each_timestamp
                    self.converted_gyro.timestamp = each_timestamp
                    self.quat.timestamp = each_timestamp

        elif data[0] == 40:
            self.data = data
            self.type = int.from_bytes(
                data[0:1], byteorder=&#39;big&#39;, signed=False)
            self.timestamp = int.from_bytes(
                data[18:20], byteorder=&#39;big&#39;, signed=False)

            self.acc = AccData()
            self.acc.x = int.from_bytes(
                data[14:15], byteorder=&#39;big&#39;, signed=True)/127
            self.acc.y = int.from_bytes(
                data[15:16], byteorder=&#39;big&#39;, signed=True)/127
            self.acc.z = int.from_bytes(
                data[16:17], byteorder=&#39;big&#39;, signed=True)/127

            self.converted_acc = AccData()
            amp_acc = [2, 4, 8, 16][sensor_range.acc]
            self.converted_acc.x = self.acc.x * amp_acc
            self.converted_acc.y = self.acc.y * amp_acc
            self.converted_acc.z = self.acc.z * amp_acc

            self.gyro = GyroData()
            self.gyro.x = int.from_bytes(
                data[9:10], byteorder=&#39;big&#39;, signed=True)/127
            self.gyro.y = int.from_bytes(
                data[10:11], byteorder=&#39;big&#39;, signed=True)/127
            self.gyro.z = int.from_bytes(
                data[11:12], byteorder=&#39;big&#39;, signed=True)/127

            self.converted_gyro = GyroData()
            amp_gyro = [250, 500, 1000, 2000][sensor_range.gyro]
            self.converted_gyro.x = self.gyro.x * amp_gyro
            self.converted_gyro.y = self.gyro.y * amp_gyro
            self.converted_gyro.z = self.gyro.z * amp_gyro

            self.quat = QuatData()
            self.quat.w = int.from_bytes(
                data[1:3], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.x = int.from_bytes(
                data[3:5], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.y = int.from_bytes(
                data[5:7], byteorder=&#39;big&#39;, signed=True) / 32768
            self.quat.z = int.from_bytes(
                data[7:9], byteorder=&#39;big&#39;, signed=True) / 32768

            self.acc.serial_number = 0
            self.converted_acc.serial_number = 0
            self.gyro.serial_number = 0
            self.converted_gyro.serial_number = 0
            self.quat.serial_number = 0
            self.acc.packet_number = 0
            self.converted_acc.packet_number = 0
            self.gyro.packet_number = 0
            self.converted_gyro.packet_number = 0
            self.quat.packet_number = 0

            self.acc.timestamp = self.timestamp
            self.gyro.timestamp = self.timestamp
            self.quat.timestamp = self.timestamp
            self.converted_acc.timestamp = self.timestamp
            self.converted_gyro.timestamp = self.timestamp

        # コールバック関数が設定されている場合、コールバック関数を呼び出す
        if hasattr(owner, &#39;got_acc_callback&#39;) and owner.got_acc_callback:
            owner.got_acc_callback(self.acc)
        if hasattr(owner, &#39;got_converted_acc_callback&#39;) and owner.got_converted_acc_callback:
            owner.got_converted_acc_callback(self.converted_acc)
        if hasattr(owner, &#39;got_gyro_callback&#39;) and owner.got_gyro_callback:
            owner.got_gyro_callback(self.gyro)
        if hasattr(owner, &#39;got_converted_gyro_callback&#39;) and owner.got_converted_gyro_callback:
            owner.got_converted_gyro_callback(self.converted_gyro)
        if hasattr(owner, &#39;got_quat_callback&#39;) and owner.got_quat_callback:
            owner.got_quat_callback(self.quat)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="orphe_core.to_timestamp" href="#orphe_core.to_timestamp">to_timestamp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orphe_core.AccData" href="#orphe_core.AccData">AccData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.DeviceInformation" href="#orphe_core.DeviceInformation">DeviceInformation</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.GyroData" href="#orphe_core.GyroData">GyroData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.Orphe" href="#orphe_core.Orphe">Orphe</a></code></h4>
<ul class="">
<li><code><a title="orphe_core.Orphe.connect" href="#orphe_core.Orphe.connect">connect</a></code></li>
<li><code><a title="orphe_core.Orphe.disconnect" href="#orphe_core.Orphe.disconnect">disconnect</a></code></li>
<li><code><a title="orphe_core.Orphe.print_device_information" href="#orphe_core.Orphe.print_device_information">print_device_information</a></code></li>
<li><code><a title="orphe_core.Orphe.read_device_information" href="#orphe_core.Orphe.read_device_information">read_device_information</a></code></li>
<li><code><a title="orphe_core.Orphe.sensor_values_notification_handler" href="#orphe_core.Orphe.sensor_values_notification_handler">sensor_values_notification_handler</a></code></li>
<li><code><a title="orphe_core.Orphe.set_acc_range" href="#orphe_core.Orphe.set_acc_range">set_acc_range</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_acc_callback" href="#orphe_core.Orphe.set_got_acc_callback">set_got_acc_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_converted_acc_callback" href="#orphe_core.Orphe.set_got_converted_acc_callback">set_got_converted_acc_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_converted_gyro_callback" href="#orphe_core.Orphe.set_got_converted_gyro_callback">set_got_converted_gyro_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_gyro_callback" href="#orphe_core.Orphe.set_got_gyro_callback">set_got_gyro_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_got_quat_callback" href="#orphe_core.Orphe.set_got_quat_callback">set_got_quat_callback</a></code></li>
<li><code><a title="orphe_core.Orphe.set_gyro_range" href="#orphe_core.Orphe.set_gyro_range">set_gyro_range</a></code></li>
<li><code><a title="orphe_core.Orphe.set_led" href="#orphe_core.Orphe.set_led">set_led</a></code></li>
<li><code><a title="orphe_core.Orphe.start_sensor_values_notification" href="#orphe_core.Orphe.start_sensor_values_notification">start_sensor_values_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.start_step_analysis_notification" href="#orphe_core.Orphe.start_step_analysis_notification">start_step_analysis_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.stop_sensor_values_notification" href="#orphe_core.Orphe.stop_sensor_values_notification">stop_sensor_values_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.stop_step_analysis_notification" href="#orphe_core.Orphe.stop_step_analysis_notification">stop_step_analysis_notification</a></code></li>
<li><code><a title="orphe_core.Orphe.write_device_information" href="#orphe_core.Orphe.write_device_information">write_device_information</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orphe_core.QuatData" href="#orphe_core.QuatData">QuatData</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.Range" href="#orphe_core.Range">Range</a></code></h4>
</li>
<li>
<h4><code><a title="orphe_core.SensorValuesData" href="#orphe_core.SensorValuesData">SensorValuesData</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>